{"entries":[{"timestamp":1746370479575,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":80,"length1":89,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":187,"length1":45,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":216,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"shooting.ts","value":"/**\n * Shooting blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\\uf0fb\"\nnamespace shooting {\n    const stateNamespace = \"__shooting_pack\";\n\n    /**\n     * HPステータスバーをスプライトに設定する\n     */\n    //% block=\"HPステータスバーをスプライト%sprite=variables_get(mySprite) に設定する || (幅: %width , 高さ: %height, オフセット: %offset)\"\n    //% expandableArgumentMode=\"toggle\"\n    //% inlineInputMode=inline\n    //% width.defl=20\n    //% height.defl=4\n    //% offset.defl=4\n    //% group=\"HPステータスバー\"\n    //% weight=94\n    export function setHPStatusBarToSprite(sprite: Sprite, width: number = 20, height: number = 4, offset: number = 4) {\n        let statusbar = statusbars.create(width, height, StatusBarKind.Health)\n        statusbar.attachToSprite(sprite)\n        statusbar.setOffsetPadding(0, offset)\n    }\n\n    /*\n     * スプライトのHPステータスバーの値を変える\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) のHPステータスバーの値を%value だけ変える\"\n    //% value.defl=-10\n    //% group=\"HPステータスバー\"\n    //% weight=92\n    export function changeHPStatusBarValue(sprite: Sprite, value: number = -10) {\n        let statusbar = statusbars.getStatusBarAttachedTo(StatusBarKind.Health, sprite)\n        if (statusbar) {\n            if (value > 0) {\n                statusbar.value = Math.min(100, statusbar.value + value)\n            } else {\n                statusbar.value = Math.max(0, statusbar.value + value)\n            }\n        }\n    }\n\n    /**\n     * HPステータスバーがゼロになったとき\n     */\n    //% block=\"HPステータスバーがゼロになったとき\"\n    //% draggableParameters=\"reporter\"\n    //% group=\"HPステータスバー\"\n    //% weight=91\n    export function onHPStatusBarZero(handler: (sprite: Sprite, kind: number) => void) {\n        const dataKey = `${stateNamespace}_on_hp_zero`\n        let handlers = game.currentScene().data[dataKey] as ((sprite: Sprite, spriteKind: number) => void)[]\n        if (!handlers) {\n            handlers = game.currentScene().data[dataKey] = [] as ((sprite: Sprite, spriteKind: number) => void)[]\n        }\n        handlers.push(handler)\n    }\n\n    statusbars.onZero(StatusBarKind.Health, (statusbar: StatusBarSprite) => {\n        const dataKey = `${stateNamespace}_on_hp_zero`\n        const handlers = (game.currentScene().data[dataKey] || []) as ((sprite: Sprite, spriteKind: number) => void)[]\n        for (let i = 0; i < handlers.length; i++) {\n            const handler = handlers[i]\n            const sprite = statusbar.spriteAttachedTo()\n            handler(sprite, sprite.kind());\n        }\n    })\n\n    function alignItems(items: Sprite[]) {\n        const itemLeft = info.hasLife() ? Math.round(32 + (Math.log(info.life()) / Math.log(10) + 1) * 5) : 8\n        let x = itemLeft\n        let y = 8\n        const scale = 0.6\n        const gap = 6\n        items.forEach((item) => {\n            item.setPosition(x, y)\n            item.setScale(scale, ScaleAnchor.Middle)\n            item.setFlag(SpriteFlag.RelativeToCamera, true)\n            x += item.width * scale + gap\n            if (x > screen.width * 0.85) {\n                x = itemLeft\n                y += 12\n            }\n        })\n    }\n\n    /**\n     * スプライトにアイテムを追加する\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) にアイテム%item=variables_get(item)を追加する\"\n    //% group=\"アイテム管理\"\n    //% weight=89\n    export function addItemToSprite(sprite: Sprite, item: Sprite) {\n        if (!sprite || !item) return\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) {\n            spriteDicts = game.currentScene().data[dataKey] = {}\n        }\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData | undefined\n        if (data) {\n            if (data.items && data.items.indexOf(item) < 0) {\n                data.items.push(item)\n            } else {\n                data.items = [item]\n            }\n        } else {\n            data = {\n                sprite: sprite,\n                items: [item]\n            }\n        }\n        spriteDicts[sprite.id] = data\n\n        let handlers = game.currentScene().data[`${stateNamespace}_handlers`] as AnimationHandlers\n        if (!handlers || !handlers.itemHandlerRegistered) {\n            if (!handlers) handlers = { itemHandlerRegistered: true }\n            else handlers.itemHandlerRegistered = true\n\n            game.eventContext().registerFrameHandler(scene.ANIMATION_UPDATE_PRIORITY, () => {\n                alignItems(data.items);\n            })\n        }\n        game.currentScene().data[`${stateNamespace}_handlers`] = handlers\n    }\n\n\n    /**\n     * スプライトにアイテムがアイテムを保持しているかチェックする (Spriteでチェックする)\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) が%item=variables_get(item) をアイテムとして保持している\"\n    //% group=\"アイテム管理\"\n    //% weight=88\n    export function spriteHasSpriteItem(sprite: Sprite, itemSprite: Sprite): boolean {\n        if (!sprite || !itemSprite) return false;\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) return false\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData\n        if (!data || !data.items) return false\n\n        let hasItem = false\n        data.items.forEach((item: Sprite) => {\n            if (item === itemSprite) hasItem = true\n        })\n        return hasItem\n    }\n\n\n    /**\n     * スプライトがアイテムを保持しているかチェックする (kindでチェックする)\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) が%kind=spritekind タイプのアイテムを保持している\"\n    //% group=\"アイテム管理\"\n    //% weight=87\n    export function spriteHasItem(sprite: Sprite, kind: number): boolean {\n        if (!sprite) return false;\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) return false\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData\n        if (!data || !data.items) return false\n\n        let hasItem = false\n        data.items.forEach((item: Sprite) => {\n            if (item.kind() === kind) hasItem = true\n        })\n        return hasItem\n    }\n\n\n    /**\n     * スプライトの保持アイテムからアイテムを削除する (Sprite指定)\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) の保持アイテムからアイテム%itemSprite=variables_get(item) を削除する\"\n    //% group=\"アイテム管理\"\n    //% weight=86\n    export function deleteItemSprite(sprite: Sprite, itemSprite: Sprite): void {\n        if (!sprite) return\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) return\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData\n        if (!data || !data.items) return\n\n        const deleteIndex: number[] = [];\n        data.items.forEach((item: Sprite, index: number) => {\n            if (item === itemSprite) {\n                item.destroy()\n                deleteIndex.push(index)\n            }\n        })\n        deleteIndex.reverse()\n        for (const i of deleteIndex) {\n            data.items.splice(i, 1)\n        }\n        spriteDicts[sprite.id] = data\n    }\n\n\n    /**\n     * スプライトの保持アイテムからアイテムを削除する (kind指定)\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) の保持アイテムから%kind=spritekind タイプのアイテムを削除する\"\n    //% group=\"アイテム管理\"\n    //% weight=85\n    export function deleteItem(sprite: Sprite, kind: number): void {\n        if (!sprite) return\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) return\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData\n        if (!data || !data.items) return\n\n        const deleteIndex: number[] = [];\n        data.items.forEach((item: Sprite, index: number) => {\n            if (item.kind() === kind) {\n                item.destroy()\n                deleteIndex.push(index)\n            }\n        })\n        deleteIndex.reverse()\n        for (const i of deleteIndex) {\n            data.items.splice(i, 1)\n        }\n\n        alignItems(data.items)\n        spriteDicts[sprite.id] = data\n    }}\n"}]},{"timestamp":1746371075429,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1351,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"shooting.ts","patch":[{"start1":23,"length1":74,"diffs":[[1,""]]},{"start1":138,"length1":171,"diffs":[[1,""]]},{"start1":146,"length1":686,"diffs":[[1,""]]},{"start1":7882,"length1":8,"diffs":[[1,"    }}\n"]]}]}]},{"timestamp":1746371670705,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"5ae7c5T8}$+02x;Q)AB7\">projectile</variable></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"variables_set\"><field name=\"VAR\" id=\"5ae7c5T8}$+02x;Q)AB7\">projectile</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"spritescreateprojectilefromside\"><value name=\"img\"><shadow type=\"screen_image_picker\"><field name=\"img\">img`\n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n`</field><data>{\"commentRefs\":[],\"fieldData\":{\"img\":null}}</data></shadow></value><value name=\"vx\"><shadow type=\"spriteSpeedPicker\"><field name=\"speed\">50</field></shadow></value><value name=\"vy\"><shadow type=\"spriteSpeedPicker\"><field name=\"speed\">50</field></shadow></value></block></value></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,""]]}]},{"type":"edited","filename":"shooting.ts","patch":[{"start1":391,"length1":1535,"diffs":[[1,""]]},{"start1":789,"length1":18,"diffs":[[1,"    //% weight=99 help=sprites/create-projectile-from-side\n"]]},{"start1":915,"length1":184,"diffs":[[1,"    export function createEnemyFromSide(img: Image, vx: number, vy: number) {\n        return createProjectile(img, vx, vy, SpriteKind.Projectile);\n"]]}]}]},{"timestamp":1746372236519,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":306,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"shooting.ts","patch":[{"start1":2324,"length1":59,"diffs":[[1,"    //% weight=99\n"]]},{"start1":2498,"length1":79,"diffs":[[1,"        const enemy: Sprite = createEnemy(img, vx, vy, SpriteKind.Enemy);\n"]]},{"start1":2608,"length1":2642,"diffs":[[1,""]]}]}]},{"timestamp":1746372838765,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":306,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]}]},{"timestamp":1746372858049,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":103,"length1":213,"diffs":[[1,"        \"pxt-status-bar\": \"github:jwunderl/pxt-status-bar#v0.4.2\"\n"]]},{"start1":306,"length1":79,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"shooting.ts","patch":[{"start1":101,"length1":59,"diffs":[[1,"//% weight=100 color=#0fbc11 icon=\"\\uf0fb\"\n"]]},{"start1":391,"length1":0,"diffs":[[1,"     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"敵スプライト\"\n    //% blockId=spritescreateenemy block=\"敵スプライト %img=screen_image_picker を速度 vx %vx vy %vy で生成する||タイプ %kind=%kind=spritekind\"\n    //% weight=99\n    //% inlineInputMode=inline\n    //% blockHidden=true\n    export function createEnemy(img: Image, vx: number, vy: number, kind?: number) {\n        const s = sprites.create(img, kind || SpriteKind.Enemy);\n        const sc = game.currentScene();\n\n        s.vx = vx;\n        s.vy = vy;\n\n        // put it at the edge of the screen so that it moves towards the middle\n        // If the scene has a tile map, place the sprite fully on the screen\n        const xOff = sc.tileMap ? -(s.width >> 1) : (s.width >> 1) - 1;\n        const yOff = sc.tileMap ? -(s.height >> 1) : (s.height >> 1) - 1;\n        const cam = game.currentScene().camera;\n\n        let initialX = cam.offsetX;\n        let initialY = cam.offsetY;\n\n        if (vx < 0) {\n            initialX += screen.width + xOff;\n        } else if (vx > 0) {\n            initialX += -xOff;\n        }\n\n        if (vy < 0) {\n            initialY += screen.height + yOff;\n        } else if (vy > 0) {\n            initialY += -yOff;\n        }\n\n        s.setPosition(initialX, initialY);\n\n        s.flags |= sprites.Flag.AutoDestroy | sprites.Flag.DestroyOnWall;\n\n        return s;\n    }\n\n    /**\n     * Create a new sprite with a given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen.\n     */\n    //% group=\"敵スプライト\"\n    //% blockId=spritescreateenemyfromside block=\"敵スプライト %img=screen_image_picker を横 (y %y) から速度 vx %vx vy %vy で生成する\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-side\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    export function createEnemyFromSide(img: Image, y: number, vx: number, vy: number) {\n        const enemy: Sprite = createProjectile(img, vx, vy, SpriteKind.Enemy);\n        enemy.y = y;\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectile block=\"projectile %img=screen_image_picker vx %vx vy %vy of kind %kind=spritekind||from sprite %sprite=variables_get(mySprite)\"\n    //% weight=99 help=sprites/create-projectile\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% expandableArgumentMode=toggle\n    //% deprecated=true blockHidden=true\n    export function createProjectile(img: Image, vx: number, vy: number, kind?: number, sprite?: Sprite) {\n        const s = sprites.create(img, kind || SpriteKind.Projectile);\n        const sc = game.currentScene();\n\n        s.vx = vx;\n        s.vy = vy;\n\n        if (sprite) {\n            s.setPosition(sprite.x, sprite.y);\n        } else {\n            // put it at the edge of the screen so that it moves towards the middle\n            // If the scene has a tile map, place the sprite fully on the screen\n            const xOff = sc.tileMap ? -(s.width >> 1) : (s.width >> 1) - 1;\n            const yOff = sc.tileMap ? -(s.height >> 1) : (s.height >> 1) - 1;\n            const cam = game.currentScene().camera;\n\n            let initialX = cam.offsetX;\n            let initialY = cam.offsetY;\n\n            if (vx < 0) {\n                initialX += screen.width + xOff;\n            } else if (vx > 0) {\n                initialX += -xOff;\n            }\n\n            if (vy < 0) {\n                initialY += screen.height + yOff;\n            } else if (vy > 0) {\n                initialY += -yOff;\n            }\n\n            s.setPosition(initialX, initialY);\n        }\n\n        s.flags |= sprites.Flag.AutoDestroy | sprites.Flag.DestroyOnWall;\n\n        return s;\n    }\n\n\n    /**\n     * Create a new sprite with a given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromside block=\"projectile %img=screen_image_picker from side with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-side\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    export function createProjectileFromSide(img: Image, vx: number, vy: number) {\n        return createProjectile(img, vx, vy, SpriteKind.Projectile);\n    }\n\n\n    /**\n"]]}]},{"type":"added","filename":"test.ts","value":"// テストはここに来ます。このパッケージが拡張機能として使用されるときにはコンパイルされません。\n"}]}],"snapshots":[{"timestamp":1746370479574,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"pxt-shooting-pack\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1746372350083,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n","README.md":" ","assets.json":"","shooting.ts":"/**\n * Shooting blocks\n * https://github.com/microsoft/pxt-common-packages/blob/master/libs/game\n */\n//% weight=100 color=#0fbc11 icon=\"\\uf0fb\"\nnamespace shooting {\n    const stateNamespace = \"__shooting_pack\";\n\n    type AnimationHandlers = {\n        itemHandlerRegistered?: boolean,\n    }\n\n    type Sprite2DActionPackData = {\n        sprite: Sprite,\n        items?: Sprite[]\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"敵スプライト\"\n    //% blockId=spritescreateenemy block=\"敵スプライト %img=screen_image_picker を速度 vx %vx vy %vy で生成する||タイプ %kind=%kind=spritekind\"\n    //% weight=99\n    //% inlineInputMode=inline\n    //% blockHidden=true\n    export function createEnemy(img: Image, vx: number, vy: number, kind?: number) {\n        const s = sprites.create(img, kind || SpriteKind.Enemy);\n        const sc = game.currentScene();\n\n        s.vx = vx;\n        s.vy = vy;\n\n        // put it at the edge of the screen so that it moves towards the middle\n        // If the scene has a tile map, place the sprite fully on the screen\n        const xOff = sc.tileMap ? -(s.width >> 1) : (s.width >> 1) - 1;\n        const yOff = sc.tileMap ? -(s.height >> 1) : (s.height >> 1) - 1;\n        const cam = game.currentScene().camera;\n\n        let initialX = cam.offsetX;\n        let initialY = cam.offsetY;\n\n        if (vx < 0) {\n            initialX += screen.width + xOff;\n        } else if (vx > 0) {\n            initialX += -xOff;\n        }\n\n        if (vy < 0) {\n            initialY += screen.height + yOff;\n        } else if (vy > 0) {\n            initialY += -yOff;\n        }\n\n        s.setPosition(initialX, initialY);\n\n        s.flags |= sprites.Flag.AutoDestroy | sprites.Flag.DestroyOnWall;\n\n        return s;\n    }\n\n    /**\n     * Create a new sprite with a given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen.\n     */\n    //% group=\"敵スプライト\"\n    //% blockId=spritescreateenemyfromside block=\"敵スプライト %img=screen_image_picker を横 (y %y) から速度 vx %vx vy %vy で生成する\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    export function createEnemyFromSide(img: Image, y: number, vx: number, vy: number) {\n        const enemy: Sprite = createEnemy(img, vx, vy, SpriteKind.Enemy);\n        enemy.y = y;\n    }\n\n    /**\n     * HPステータスバーをスプライトに設定する\n     */\n    //% block=\"HPステータスバーをスプライト%sprite=variables_get(mySprite) に設定する || (幅: %width , 高さ: %height, オフセット: %offset)\"\n    //% expandableArgumentMode=\"toggle\"\n    //% inlineInputMode=inline\n    //% width.defl=20\n    //% height.defl=4\n    //% offset.defl=4\n    //% group=\"HPステータスバー\"\n    //% weight=94\n    export function setHPStatusBarToSprite(sprite: Sprite, width: number = 20, height: number = 4, offset: number = 4) {\n        let statusbar = statusbars.create(width, height, StatusBarKind.Health)\n        statusbar.attachToSprite(sprite)\n        statusbar.setOffsetPadding(0, offset)\n    }\n\n    /*\n     * スプライトのHPステータスバーの値を変える\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) のHPステータスバーの値を%value だけ変える\"\n    //% value.defl=-10\n    //% group=\"HPステータスバー\"\n    //% weight=92\n    export function changeHPStatusBarValue(sprite: Sprite, value: number = -10) {\n        let statusbar = statusbars.getStatusBarAttachedTo(StatusBarKind.Health, sprite)\n        if (statusbar) {\n            if (value > 0) {\n                statusbar.value = Math.min(100, statusbar.value + value)\n            } else {\n                statusbar.value = Math.max(0, statusbar.value + value)\n            }\n        }\n    }\n\n    /**\n     * HPステータスバーがゼロになったとき\n     */\n    //% block=\"HPステータスバーがゼロになったとき\"\n    //% draggableParameters=\"reporter\"\n    //% group=\"HPステータスバー\"\n    //% weight=91\n    export function onHPStatusBarZero(handler: (sprite: Sprite, kind: number) => void) {\n        const dataKey = `${stateNamespace}_on_hp_zero`\n        let handlers = game.currentScene().data[dataKey] as ((sprite: Sprite, spriteKind: number) => void)[]\n        if (!handlers) {\n            handlers = game.currentScene().data[dataKey] = [] as ((sprite: Sprite, spriteKind: number) => void)[]\n        }\n        handlers.push(handler)\n    }\n\n    statusbars.onZero(StatusBarKind.Health, (statusbar: StatusBarSprite) => {\n        const dataKey = `${stateNamespace}_on_hp_zero`\n        const handlers = (game.currentScene().data[dataKey] || []) as ((sprite: Sprite, spriteKind: number) => void)[]\n        for (let i = 0; i < handlers.length; i++) {\n            const handler = handlers[i]\n            const sprite = statusbar.spriteAttachedTo()\n            handler(sprite, sprite.kind());\n        }\n    })\n\n    function alignItems(items: Sprite[]) {\n        const itemLeft = info.hasLife() ? Math.round(32 + (Math.log(info.life()) / Math.log(10) + 1) * 5) : 8\n        let x = itemLeft\n        let y = 8\n        const scale = 0.6\n        const gap = 6\n        items.forEach((item) => {\n            item.setPosition(x, y)\n            item.setScale(scale, ScaleAnchor.Middle)\n            item.setFlag(SpriteFlag.RelativeToCamera, true)\n            x += item.width * scale + gap\n            if (x > screen.width * 0.85) {\n                x = itemLeft\n                y += 12\n            }\n        })\n    }\n\n    /**\n     * スプライトにアイテムを追加する\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) にアイテム%item=variables_get(item)を追加する\"\n    //% group=\"アイテム管理\"\n    //% weight=89\n    export function addItemToSprite(sprite: Sprite, item: Sprite) {\n        if (!sprite || !item) return\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) {\n            spriteDicts = game.currentScene().data[dataKey] = {}\n        }\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData | undefined\n        if (data) {\n            if (data.items && data.items.indexOf(item) < 0) {\n                data.items.push(item)\n            } else {\n                data.items = [item]\n            }\n        } else {\n            data = {\n                sprite: sprite,\n                items: [item]\n            }\n        }\n        spriteDicts[sprite.id] = data\n\n        let handlers = game.currentScene().data[`${stateNamespace}_handlers`] as AnimationHandlers\n        if (!handlers || !handlers.itemHandlerRegistered) {\n            if (!handlers) handlers = { itemHandlerRegistered: true }\n            else handlers.itemHandlerRegistered = true\n\n            game.eventContext().registerFrameHandler(scene.ANIMATION_UPDATE_PRIORITY, () => {\n                alignItems(data.items);\n            })\n        }\n        game.currentScene().data[`${stateNamespace}_handlers`] = handlers\n    }\n\n\n    /**\n     * スプライトにアイテムがアイテムを保持しているかチェックする (Spriteでチェックする)\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) が%item=variables_get(item) をアイテムとして保持している\"\n    //% group=\"アイテム管理\"\n    //% weight=88\n    export function spriteHasSpriteItem(sprite: Sprite, itemSprite: Sprite): boolean {\n        if (!sprite || !itemSprite) return false;\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) return false\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData\n        if (!data || !data.items) return false\n\n        let hasItem = false\n        data.items.forEach((item: Sprite) => {\n            if (item === itemSprite) hasItem = true\n        })\n        return hasItem\n    }\n\n\n    /**\n     * スプライトがアイテムを保持しているかチェックする (kindでチェックする)\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) が%kind=spritekind タイプのアイテムを保持している\"\n    //% group=\"アイテム管理\"\n    //% weight=87\n    export function spriteHasItem(sprite: Sprite, kind: number): boolean {\n        if (!sprite) return false;\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) return false\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData\n        if (!data || !data.items) return false\n\n        let hasItem = false\n        data.items.forEach((item: Sprite) => {\n            if (item.kind() === kind) hasItem = true\n        })\n        return hasItem\n    }\n\n\n    /**\n     * スプライトの保持アイテムからアイテムを削除する (Sprite指定)\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) の保持アイテムからアイテム%itemSprite=variables_get(item) を削除する\"\n    //% group=\"アイテム管理\"\n    //% weight=86\n    export function deleteItemSprite(sprite: Sprite, itemSprite: Sprite): void {\n        if (!sprite) return\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) return\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData\n        if (!data || !data.items) return\n\n        const deleteIndex: number[] = [];\n        data.items.forEach((item: Sprite, index: number) => {\n            if (item === itemSprite) {\n                item.destroy()\n                deleteIndex.push(index)\n            }\n        })\n        deleteIndex.reverse()\n        for (const i of deleteIndex) {\n            data.items.splice(i, 1)\n        }\n        spriteDicts[sprite.id] = data\n    }\n\n\n    /**\n     * スプライトの保持アイテムからアイテムを削除する (kind指定)\n     */\n    //% block=\"スプライト%sprite=variables_get(mySprite) の保持アイテムから%kind=spritekind タイプのアイテムを削除する\"\n    //% group=\"アイテム管理\"\n    //% weight=85\n    export function deleteItem(sprite: Sprite, kind: number): void {\n        if (!sprite) return\n\n        const dataKey = stateNamespace\n\n        let spriteDicts = game.currentScene().data[dataKey]\n        if (!spriteDicts) return\n        let data = spriteDicts[sprite.id] as Sprite2DActionPackData\n        if (!data || !data.items) return\n\n        const deleteIndex: number[] = [];\n        data.items.forEach((item: Sprite, index: number) => {\n            if (item.kind() === kind) {\n                item.destroy()\n                deleteIndex.push(index)\n            }\n        })\n        deleteIndex.reverse()\n        for (const i of deleteIndex) {\n            data.items.splice(i, 1)\n        }\n\n        alignItems(data.items)\n        spriteDicts[sprite.id] = data\n    }\n}\n","pxt.json":"{\n    \"name\": \"pxt-shooting-pack\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"pxt-status-bar\": \"github:jwunderl/pxt-status-bar#v0.4.2\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"shooting.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1746373174911}